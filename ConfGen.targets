<!--
***********************************************************************************************
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Eugene Sadovoi. All rights reserved.

Input Properties:
  PropertyPageSchema:   (Required) - This property holds full file path to XML Property 
                                     Page Schema
  Name:                 (Optional) - Name of the Rule to process
  Quote:                (Optional) - Symbol used for quotation
  SmartQuotes:          (Optional) - If set to true values will be enclosed in quotes only if 
                                     string contains space or Separator char. Enabled by default.
  TrimFolderEnd:        (Optional) - Trim trailing Char: ''  - Folder as is       
                                                        true - Trim trailing slash
                                                        false- Add trailing slash 
  FullPath              (Optional) - If true, path for folders and files will be fully resolved
***********************************************************************************************
-->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <Target Name="GetXmlConfig" Outputs="@(options, ' ');" >

    <Error ContinueOnError="false" Condition="'$(PropertyPageSchema)'==''" Text="Property 'PropertyPageSchema' is missing. Please provide file to process [PropertyPageSchema=property_shecma_file.xml]." />
    <Error ContinueOnError="false" Condition="!Exists('$(PropertyPageSchema)')" Text="File '$(PropertyPageSchema)' is missing. Please provide correct path." />

    <PropertyGroup>
      <NameFilter Condition="'$(Name)'!=''" >[@Name='$(Name)']</NameFilter>
      <TempFile>$([System.IO.Path]::GetTempFileName())</TempFile>
    </PropertyGroup>

    <XmlPeek Namespaces="&lt;Namespace Prefix='ns' Uri='http://schemas.microsoft.com/build/2009/properties'/&gt;"
             XmlInputPath="$(PropertyPageSchema)" Query="/ns:Rule$(NameFilter)/*[not(contains(@IncludeInCommandLine, 'false')) and contains(local-name(), 'Property')]|
                             /ns:ProjectSchemaDefinitions/ns:Rule$(NameFilter)/*[not(contains(@IncludeInCommandLine, 'false')) and contains(local-name(), 'Property')]">
      <Output TaskParameter="Result" ItemName="Peeked" />
    </XmlPeek>

    <ItemGroup Label="Parse XML">
      <Properties Remove="@(Properties)" />
      <Properties Include="$([System.Text.RegularExpressions.Regex]::Match(%(Peeked.Identity), (?&lt;=\sName=&#34;)(.*?)(?=&#34;)))">
        <Subtype>$([System.Text.RegularExpressions.Regex]::Match(%(Peeked.Identity), (?&lt;=\sSubtype=")(.*?)(?=")))</Subtype>
      </Properties>
    </ItemGroup>

    <ItemGroup>
      <data-name-map Include="$(%(Properties.Identity))"
                     Condition="'%(Properties.Identity)'   !='' And '%(%(Properties.Identity))'!='' And '%(Properties.Subtype)' !='file' And '%(Properties.Subtype)' !='folder'" >
        <Name>%(Properties.Identity)</Name>  
      </data-name-map>
      <data-files-map Include="$(%(Properties.Identity))"
                      Condition="'%(Properties.Identity)' !='' And '%(%(Properties.Identity))'!='' And '%(Properties.Subtype)'    =='file'" >
        <Name>%(Properties.Identity)</Name>
      </data-files-map>
      <data-folders-map Include="$(%(Properties.Identity))"
                        Condition="'%(Properties.Identity)'   !='' And '%(%(Properties.Identity))'!='' And '%(Properties.Subtype)'    =='folder'" >
        <Name>%(Properties.Identity)</Name>
      </data-folders-map>
      
      <temp-data Condition="'%(data-name-map.Identity)'   !=''"                                                            Include="&lt;Property Name=&#34;%(data-name-map.Name)&#34;   &gt;%(data-name-map.Identity)&lt;/Property&gt;"/>
      <temp-data Condition="'%(data-files-map.Identity)'  !='' And '$(FullPath)'!='true'"                                  Include="&lt;Property Name=&#34;%(data-files-map.Name)&#34;  &gt;%(data-files-map.Identity)&lt;/Property&gt;"/>
      <temp-data Condition="'%(data-files-map.Identity)'  !='' And '$(FullPath)'=='true'"                                  Include="&lt;Property Name=&#34;%(data-files-map.Name)&#34;  &gt;$([System.IO.Path]::GetFullPath('%(data-files-map.Identity)'))&lt;/Property&gt;"/>
      <temp-data Condition="'%(data-folders-map.Identity)'!='' And '$(FullPath)'!='true' And '$(TrimFolderEnd)'==''     "  Include="&lt;Property Name=&#34;%(data-folders-map.Name)&#34;&gt;%(data-folders-map.Identity)&lt;/Property&gt;"/>
      <temp-data Condition="'%(data-folders-map.Identity)'!='' And '$(FullPath)'!='true' And '$(TrimFolderEnd)'=='true' "  Include="&lt;Property Name=&#34;%(data-folders-map.Name)&#34;&gt;$([System.String]::Copy('%(data-folders-map.Identity)').TrimEnd($([System.IO.Path]::DirectorySeparatorChar)))&lt;/Property&gt;"/>
      <temp-data Condition="'%(data-folders-map.Identity)'!='' And '$(FullPath)'!='true' And '$(TrimFolderEnd)'=='false'"  Include="&lt;Property Name=&#34;%(data-folders-map.Name)&#34;&gt;$([System.String]::Copy('%(data-folders-map.Identity)').TrimEnd($([System.IO.Path]::DirectorySeparatorChar)))$([System.IO.Path]::DirectorySeparatorChar)&lt;/Property&gt;"/>
      <temp-data Condition="'%(data-folders-map.Identity)'!='' And '$(FullPath)'=='true' And '$(TrimFolderEnd)'==''     "  Include="&lt;Property Name=&#34;%(data-folders-map.Name)&#34;&gt;$([System.IO.Path]::GetFullPath('%(data-folders-map.Identity)'))&lt;/Property&gt;"/>
      <temp-data Condition="'%(data-folders-map.Identity)'!='' And '$(FullPath)'=='true' And '$(TrimFolderEnd)'=='true' "  Include="&lt;Property Name=&#34;%(data-folders-map.Name)&#34;&gt;$([System.IO.Path]::GetFullPath('%(data-folders-map.Identity)').TrimEnd($([System.IO.Path]::DirectorySeparatorChar)))&lt;/Property&gt;"/>
      <temp-data Condition="'%(data-folders-map.Identity)'!='' And '$(FullPath)'=='true' And '$(TrimFolderEnd)'=='false'"  Include="&lt;Property Name=&#34;%(data-folders-map.Name)&#34;&gt;$([System.IO.Path]::GetFullPath('%(data-folders-map.Identity)').TrimEnd($([System.IO.Path]::DirectorySeparatorChar)))$([System.IO.Path]::DirectorySeparatorChar)&lt;/Property&gt;"/>
    
  </ItemGroup>
    <PropertyGroup Condition="'@(temp-data)'!=''">
      <xsl-raw>
        <!--?xml version="1.0" encoding="utf-8"?-->
        <xsl:stylesheet version="1.0" 
                        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                        xmlns:msb="http://schemas.microsoft.com/build/2009/properties"
                        xmlns:msxsl="urn:schemas-microsoft-com:xslt" >
          <xsl:output method="text" indent="no"/>
          <xsl:strip-space elements="*" />
          <xsl:param name="Quote" select="'&#34;'" />
          <xsl:param name="SmartQuotes" select="'true'" />
          <xsl:variable name="Data" >@(temp-data, '')</xsl:variable>
          <xsl:template match="/">
            <xsl:apply-templates />
          </xsl:template>
          <xsl:template match="msb:ProjectSchemaDefinitions">
            <xsl:apply-templates />
          </xsl:template>
          <xsl:template match="msb:Rule">
            <xsl:variable name="DataSet" select="msxsl:node-set($Data)" />
            <xsl:apply-templates select="*[not(@IncludeInCommandLine ='false') and @Name = $DataSet/*/@Name]"  >
              <xsl:with-param name="DefaultSwitchPrefix" select="@SwitchPrefix" />
              <xsl:with-param name="DataSet" select="$DataSet" />
            </xsl:apply-templates>
          </xsl:template>
          <xsl:template match="msb:StringProperty|msb:DynamicEnumProperty|msb:IntProperty|msb:Argument|msb:EnumProperty" >
            <xsl:param name="DefaultSwitchPrefix" />
            <xsl:param name="DataSet" />
            <xsl:if test="local-name() != 'Argument'">
              <xsl:text>&#32;</xsl:text>
              <xsl:choose>
                <xsl:when test="@SwitchPrefix">
                  <xsl:value-of select="@SwitchPrefix"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:value-of select="$DefaultSwitchPrefix"/>
                </xsl:otherwise>
              </xsl:choose>
              <xsl:value-of select="@Switch"/>
            </xsl:if>
            <xsl:variable name="PropertyName">
              <xsl:choose>
                <xsl:when test="local-name() = 'Argument'" >
                  <xsl:value-of  select="self::node()/@Property" />
                </xsl:when>
                <xsl:otherwise>
                  <xsl:value-of  select="self::node()//@Name" />
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="Value" select="$DataSet/*[@Name = $PropertyName]/text()"/>
            <xsl:variable name="QuoteSym" >
              <xsl:if test="(@Separator != '' and contains($Value, @Separator)) or contains($Value, ' ') or $SmartQuotes = 'false'">
                <xsl:value-of select="$Quote" />
              </xsl:if>
            </xsl:variable>
            <xsl:value-of select="@Separator"/>
            <xsl:choose>
              <xsl:when test="local-name() = 'EnumProperty'">
                <xsl:variable name="EnumValName" select="$DataSet/*[@Name = $PropertyName]/text()"/>
                <xsl:variable name="EnumVal" select="self::node()/*[@Name = $EnumValName]" />
                <xsl:value-of select="$EnumVal/@Switch"/>
                <xsl:apply-templates select="$EnumVal/*" >
                  <xsl:with-param name="DataSet" select="$DataSet" />
                </xsl:apply-templates>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="$QuoteSym" />
                <xsl:value-of select="$Value"/>
                <xsl:value-of select="$QuoteSym" />
                <xsl:apply-templates >
                  <xsl:with-param name="DataSet" select="$DataSet" />
                </xsl:apply-templates>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:template>
          <xsl:template match="msb:EnumValue">
            <xsl:param name="DataSet" />
            <xsl:apply-templates >
              <xsl:with-param name="DataSet" select="$DataSet" />
            </xsl:apply-templates>
          </xsl:template>
          <xsl:template match="msb:BoolProperty">
            <xsl:param name="DefaultSwitchPrefix" />
            <xsl:param name="DataSet" />
            <xsl:variable name="PropertyName" select="self::node()/@Name" />
            <xsl:variable name="Value" select="$DataSet/*[@Name = $PropertyName]/text()"/>
            <xsl:text>&#32;</xsl:text>
            <xsl:choose>
              <xsl:when test="@SwitchPrefix">
                <xsl:value-of select="@SwitchPrefix"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="$DefaultSwitchPrefix"/>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:choose>
              <xsl:when test="$Value = 'true'">
                <xsl:value-of select="@Switch"/>
              </xsl:when>
              <xsl:when test="$Value = 'false'">
                <xsl:value-of select="@ReverseSwitch"/>
              </xsl:when>
            </xsl:choose>
            <xsl:apply-templates >
              <xsl:with-param name="DataSet" select="$DataSet" />
            </xsl:apply-templates>
          </xsl:template>
          <xsl:template match="msb:StringListProperty">
            <xsl:param name="DefaultSwitchPrefix" />
            <xsl:param name="DataSet" />
            <xsl:variable name="PropertyName" select="self::node()//@Name" />
            <xsl:variable name="Values"       select="$DataSet/*[@Name = $PropertyName]/text()"/>
            <xsl:variable name="List"         select="self::node()" />
            <xsl:choose>
              <xsl:when test="@CommandLineValueSeparator != ''">
                <xsl:text>&#32;</xsl:text>
                <xsl:choose>
                  <xsl:when test="@SwitchPrefix">
                    <xsl:value-of select="@SwitchPrefix"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="$DefaultSwitchPrefix"/>
                  </xsl:otherwise>
                </xsl:choose>
                <xsl:value-of select="@Switch" />
                <xsl:value-of select="@Separator" />
                <xsl:text>&#34;</xsl:text>
                <xsl:for-each select="$Values">
                  <xsl:value-of select="self::node()"/>
                  <xsl:if test="position() != last()">
                    <xsl:value-of select="$List/@CommandLineValueSeparator"/>
                  </xsl:if>
                </xsl:for-each>
                <xsl:text>&#34;</xsl:text>
                <xsl:apply-templates>
                  <xsl:with-param name="DataSet" select="$DataSet" />
                </xsl:apply-templates>
              </xsl:when>
              <xsl:otherwise>
                <xsl:for-each select="$Values">
                  <xsl:variable name="Value" select="." />
                  <xsl:variable name="QuoteSym" >
                    <xsl:if test="($List/@Separator != '' and contains($Value, $List/@Separator)) or contains($Value, ' ') or ($SmartQuotes = 'false')">
                      <xsl:value-of select="$Quote" />
                    </xsl:if>
                  </xsl:variable>
                  <xsl:text>&#32;</xsl:text>
                  <xsl:choose>
                    <xsl:when test="@SwitchPrefix">
                      <xsl:value-of select="@SwitchPrefix"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select="$DefaultSwitchPrefix"/>
                    </xsl:otherwise>
                  </xsl:choose>
                  <xsl:value-of select="$List/@Switch" />
                  <xsl:value-of select="$List/@Separator" />
                  <xsl:value-of select="$QuoteSym" />
                  <xsl:value-of select="$Value"/>
                  <xsl:value-of select="$QuoteSym" />
                  <xsl:apply-templates select="$List/*" >
                    <xsl:with-param name="DataSet" select="$DataSet" />
                  </xsl:apply-templates>
                </xsl:for-each>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:template>
        </xsl:stylesheet>
      </xsl-raw>
    </PropertyGroup>
    
    <XslTransformation Condition="'@(temp-data)'!=''" 
                       XmlInputPaths="$(PropertyPageSchema)" XslContent="$(xsl-raw)" OutputPaths="$(TempFile)"
                       Parameters="&lt;Parameter Name=&#34;SmartQuotes&#34; Value=&#34;$(SmartQuotes)&#34; /&gt;
                                   &lt;Parameter Name=&#34;Quote&#34; Value=&#34;$(Quote)&#34; /&gt;" />
    <ReadLinesFromFile Condition="'@(temp-data)'!=''" File="$(TempFile)"><Output TaskParameter="Lines" ItemName="options" /></ReadLinesFromFile>
    <Delete Condition="'@(temp-data)'!=''" Files="$(TempFile)" />
  </Target>
</Project>
